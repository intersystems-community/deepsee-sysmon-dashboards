Class kutac.monitor.utils.Installer
{

XData Install [ XMLNamespace = INSTALLER ]
{
<Manifest>
<IfNotDef Var="Namespace">
<Var Name="Namespace" Value="SYSMON"/>
<Log Text="Set namespace to ${Namespace}" Level="0"/>
</IfNotDef>


<If Condition='(##class(Config.Namespaces).Exists("${Namespace}")=0)'>
<Log Text="Creating namespace ${Namespace}" Level="0"/>

<Namespace Name="${Namespace}" Create="yes" Code="${Namespace}" Ensemble="" Data="${Namespace}">
<Log Text="Creating database ${Namespace}" Level="0"/>

<Configuration>
<Database Name="${Namespace}" Dir="${MGRDIR}/${Namespace}" Create="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/>
</Configuration>

<Log Text="End creating database ${Namespace}" Level="0"/>
</Namespace>

 <Log Text="End creating namespace ${Namespace}" Level="0"/>
</If>

<If Condition='(##class(Security.Applications).Exists($ZCONVERT("/csp/${Namespace}", "L"))=0)'>
<Namespace Name="${Namespace}" Create="no">
<Log Text="Creating web application /csp/${Namespace}" Level="0"/>

<CSPApplication Url='#{$ZCONVERT("/csp/${Namespace}", "L")}' Directory='#{##class(%DeepSee.Report.UI.reportModelServer).GetCSPDirectory()_$ZCONVERT("${Namespace}", "L")}' AuthenticationMethods="32" IsNamespaceDefault="true" Recurse="true" Grant="%All"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="EnableDeepSee"/>

<Log Text="End creating web application /csp/${Namespace}" Level="0"/>

<RunInstall Class="kutac.monitor.utils.Installer" Method="createBrokerApplication"/>
</Namespace>
</If>

<Namespace Name="${Namespace}" Create="no" Code="${Namespace}" Data="${Namespace}" Ensemble="">
<Log Text="Mapping SYS.History package to choosed namespace." Level="0"/>

<Configuration>
<ClassMapping From="CACHESYS" Package="SYS.History"/>
</Configuration>

<Log Text="Mapping SYS.History global to choosed namespace." Level="0"/>

<Configuration>
<GlobalMapping From="CACHESYS" Global="SYS.History"/>
</Configuration>

<Log Text="Mapping MONEXT routine to choosed namespace." Level="0"/>

<Configuration>
<RoutineMapping From="CACHESYS" Routines="MONEXT"/>
</Configuration>

<RunInstall Class="kutac.monitor.utils.Installer" Method="CopyClasses"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="CopyDFI"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="CopyFiles"/>
</Namespace>

<Log Text="Moving to configuring monitor" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="ConfiguringMonitor"/>

</Manifest>
}

///  This is a method generator whose code is generated by XGL.
/// Set pVars("Namespace")="SYSMON"
/// Set pVars("SourceDir")="C:\temp\SYSMON\cls\kutac\"
/// do ##class(kutac.monitor.utils.Installer).setup(.pVars)
ClassMethod setup(ByRef pVars, pLogLevel As %Integer = 0, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Install")
}

ClassMethod EnableDeepSee(pVars, pLogLevel, tInstaller) As %Status
{
	set namespace = tInstaller.Evaluate("${Namespace}")
	w "Turn on DeepSee flag on "_namespace_" Web Application.", !
	set tSC = $$$OK
    try {
        new $Namespace
        set $Namespace = "%SYS"
        
        set tApplication = ##class(Security.Applications).%OpenId("/csp/"_$ZCONVERT(namespace, "L"),,.tSC)
        if $$$ISERR(tSC) {
	        do $system.Status.DisplayError(tSC)
            quit
        }
        
        set tApplication.DeepSeeEnabled = 1
        set tSC = tApplication.%Save()
    } catch e {
        set tSC = e.AsStatus()
    }
    
    do $system.Status.DisplayError(tSC)
    quit tSC
}

ClassMethod ConfiguringMonitor(pVars, pLogLevel, tInstaller) As %Status
{
	set Namespace=tInstaller.Evaluate("${Namespace}")
	
	do tInstaller.PushNS(Namespace)
	do $system.OBJ.CompilePackage("kutac.monitor.history,"_
								  "kutac.monitor.kpi,"_
								  "kutac.monitor.current,"_
								  "kutac.monitor.library,"_
								  "kutac.monitor.task,"_
								  "kutac.monitor.utils"_
								  "kutac.REST","cuk")
								  
	do $system.OBJ.CompilePackage("kutac.monitor.cubes","cuk")
	do tInstaller.PopNS()
	
	do tInstaller.PushNS("%SYS")
	
	do ..WriteLog("Activating Monitor Classes")
	set st2 = ..ActivatingClasses()
	
	do ..WriteLog("Starting Monitor")
	set st3 = ..RunningMonitor()
	
	&sql(select id into :TaskID from %SYS.Task where Name = 'Rebuild SYSMON Cubes')
	do tInstaller.PopNS()
	
	do tInstaller.PushNS(Namespace)
	if +SQLCODE {
		do ..WriteLog("Creating Task")
		Do ##class(kutac.monitor.task.Builder).Setup()
	} else {
		do ##class(%SYS.Task).Resume(TaskID)
		do ##class(%SYS.Task).RunNow(TaskID)
	}
	
	do tInstaller.PopNS()
	
	do tInstaller.PushNS("%SYS")
	set SSLConfig = "EmailDefault"
	do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)
	do ##class(%Monitor.Manager).AppSmtpServer(,,.SSLConfig)
	do tInstaller.PopNS()
		
	set st = $$$ADDSC(st2, st3)
	if $$$ISERR(st) Throw ##class(%Installer.Exception).CreateFromStatus(st)
    quit $$$OK
}

ClassMethod ActivatingClasses() As %Status
{
	set act = $LISTBUILD("%Monitor.System.HistoryPerf","%Monitor.System.Diskspace","%Monitor.System.License","%Monitor.System.Processes","%Monitor.System.HistorySys","%Monitor.System.Freespace","%Monitor.System.LockTable","%Monitor.System.Routines")
	set str = $LISTTOSTRING(act)
	for i = 1:1:$LISTLENGTH(act)
	{
		set cls = $PIECE(str, ",", i)
		set id = ""
		do ##class(%Monitor.ItemGroup).MetricsClassItemGroup(cls,.id)
 		s class = ##class(%Monitor.ItemGroup).%OpenId(id)
 		if '$IsObject(class)
 		{ 
 			do ..WriteLog("ERROR: Class '"_cls_"' does not exist")
 		}
 		else
 		{
	 		set class.Activated = 1
	 		set status = class.%Save()
	 		if ('status) 
	 		{
		 		w $System.Status.GetErrorText(st)
	 		}
 		}
	}
	return $$$OK
}

ClassMethod RunningMonitor() As %Status
{
	s sc = ##class(%SYS.Monitor).Stop()
	s sc1 = ##class(%SYS.Monitor).Start()
	do ..WriteLog("System Monitor has been restarted!")
	return sc1
}

ClassMethod OfflineInstall(ByRef pVars, pLogLevel As %Integer = 0, tInstaller As %Installer.Installer) As %Status
{
	set ns = $Namespace
	set namespace = tInstaller.Evaluate("${Namespace}")
	
	zn namespace
	do $system.OBJ.ImportDir(tInstaller.Evaluate("${SourceDir}"),"*.xml","ck",.st,1)
	
	zn ns
	quit $$$OK
}

ClassMethod WriteLog(text As %String)
{
	w !, text, !
}

ClassMethod createBrokerApplication(pVars, pLogLevel, tInstaller) As %Status
{
	set Namespace = tInstaller.Evaluate("${Namespace}")
	do tInstaller.PushNS("%SYS")
	set cspProperties("NameSpace") = Namespace
	set cspProperties("AutheEnabled") = $$$AutheCache
	set cspProperties("IsNameSpaceDefault") = $$$NO
	set cspProperties("DispatchClass") = "kutac.REST.ConfigBroker"
	set cspProperties("GroupById") = "sysmon"
	set cspProperties("MatchRoles") = ":%All"
	set cspProperties("CookiePath") = "/"
	
	set tSC = ##class(Security.Applications).Create("/sysmon", .cspProperties)
	if $$$ISERR(tSC) throw ##class(%Installer.Exception).CreateFromStatus(tSC)
	kill cspProperties, security
	do tInstaller.PopNS()
	
	quit $$$OK
}

ClassMethod CopyClasses(pVars, pLogLevel, tInstaller)
{
	
	set sc = $$$OK
	
	set i = 0
	while 1 {
		set id = "SYSMON.CLSData||File" _ i
		if (##class(%Dictionary.CompiledXData).%ExistsId(id) = 0) Q	
		set class = ##class(%Dictionary.CompiledXData).%OpenId(id)
		set data = $zconvert(class.Data.Read(class.Data.Size), "O", "UTF8")
		set className = $piece(class.Description,".",1,*-1)
		
		set Namespace = tInstaller.Evaluate("${Namespace}")
		do tInstaller.PushNS(Namespace)
		
		if ('##class(%Dictionary.ClassDefinition).%ExistsId(className)) {
			set clsDef = ##class(%Dictionary.ClassDefinition).%New()
			set clsDef.Name = className
			set sc = clsDef.%Save()
			quit:$$$ISERR(sc) 
		}
		
		set sc = ##class(%Compiler.UDL.TextServices).SetTextFromString(,className,$System.Encryption.Base64Decode(data))
		
		do tInstaller.PopNS()
		
		set i = i + 1
	}
		
	quit sc
}

ClassMethod CopyDFI(pVars, pLogLevel, tInstaller)
{
	set sc = $$$OK
	
	set i = 0
	while 1 {
		set id = "SYSMON.DFIData||File" _ i
		if (##class(%Dictionary.CompiledXData).%ExistsId(id) = 0) Q		
		set dfi = ##class(%Dictionary.CompiledXData).%OpenId(id)
		
		set data = ##class(%GlobalCharacterStream).%New()
		do data.Clear()
		do data.Write($zconvert(dfi.Data.Read(dfi.Data.Size), "O", "UTF8"))
		
		set dfiName = $piece(dfi.Description,".",1)
		
		set Namespace = tInstaller.Evaluate("${Namespace}")
		do tInstaller.PushNS(Namespace)
		
		if '##class(%DeepSee.UI.FolderItemDocument).%ExistsId(dfiName) {
			try {
		        set tDoc = ##class(%DeepSee.UI.FolderItemDocument).%New(dfiName)
		        set sc = tDoc.ImportFromXML(data)
		        
		        set sc = tDoc.Save()
		        do tInstaller.Log(pLogLevel, "Creating DFI", dfiName)
		    } Catch e {
		        set sc = e.AsStatus()
		    }
		} else {
			try {
				set tDoc = ##class(%DeepSee.UI.FolderItemDocument).%OpenId(dfiName)
				set sc = tDoc.ImportFromXML(data)
				
				set sc = tDoc.Save()
				do tInstaller.Log(pLogLevel, "Creating DFI", dfiName)
			} Catch e {
		        set sc = e.AsStatus()
		    }
		}
		
		do tInstaller.PopNS()
		
		set i = i + 1
	}
	
	quit $$$OK
}

ClassMethod CopyFiles(pVars, pLogLevel, tInstaller)
{
	set csp = tInstaller.Evaluate("${CSPDIR}")
	set appdir = tInstaller.Evaluate("${Namespace}")
	set path = ##class(%File).NormalizeDirectory(csp _ appdir)	
	
	// Get path separator
	set r = ##class(%File).NormalizeDirectory("\")
	if ($find(r, "/") = 0) { 
		set r = "\"
	} else {
		 set r = "/"
	}
	
	set i = 0
	while 1 {
		set id = "SYSMON.CSPData||File" _ i		
		if (##class(%Dictionary.CompiledXData).%ExistsId(id) = 0) Q		
		set file = ##class(%Dictionary.CompiledXData).%OpenId(id)
		
		set data = $zconvert(file.Data.Read(file.Data.Size), "O", "UTF8")
		set fileName = ##class(%File).NormalizeFilename(path _ file.Description)
		
		
		set fileName = $replace(fileName, "\", r)
		set fileName = $replace(fileName, "/", r)
		set dir = ##class(%File).ParentDirectoryName(fileName)
		if ('##class(%File).DirectoryExists(dir)) {
			do ##class(%File).CreateDirectory(dir)
		}
		
		do tInstaller.Log(pLogLevel, "Creating file", fileName)
		
		
		set f = ##class(%Stream.FileBinary).%New()
    	do f.LinkToFile(fileName)
    	do f.Write($System.Encryption.Base64Decode(data))
    	do f.%Save()
				
		set i = i + 1
	}
	
	quit $$$OK
}

}

